means[i] <- mean(y[, i])
}
means
}
columnmean <- funciton(y){
nc <- ncol(y)
means <- nummeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean <- funciton(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean <- funciton(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean <- funciton(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean <- funciton(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
numeric(1)
numeric(23)
numeric(3)
numeric(3.4)
numeric(3.5)
numeric(3.6)
numeric(5)
ncol(5)
y <- c(1,2,4,5,7)
ncol(y)
q()
plot(x,y,"l",...)
plot(x, y, type="l", ...)
plot(x, y, type = "l", ...)
q()
cube <- function(x,n){
x^3
}
cube(3)
X<-1:10
X
if(X>5){
x<-0
}
f <- function(x) {
g <- function(y) {
y + Z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3){}
y <- if(x < 3) {
NA
} else {
10
}
y
install.packages("KernSmooth")
library(KernSmooth)
q()
x <- list(a=1:5, b=rnorm(10))
x
lapply(x, mean)
x <- list(a=1:4, b=rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
x
lapply(x, mean)
runif
x <- 1:4
lapply(x ,runif)
x
runif(1)
runif(2)
runif(4)
runif(10)
punif
punif(1)
punif(2)
punif(4)
dunif(1)
dunif(2)
dunif(3)
dunif(0.5)
x <- 1:4
lapply(x, runif, min = 0, max = 10)
x <- list(a=matrix(1:4, 2, 2), b=matrix(1:6, 3,2))
x
lapply(x, function(elt) elt[,1])
elt[,1]
x
x <- list(a=1:4, b=rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
x
rnorm
x
sapply(x, mean)
x
mean(x)
x <- matric(rnorm(200),20,10)
x <- matrix(rnorm(200),20,10)
x
apply(x,2,mean)
apply(x,1,mean)
x <- matrix(rnorm(200), 20, 10)
x
rnorm(200)
apply(x,1,quantile, probs = c(0.25, 0.75))
a <- array(rnorm(2*2*10), c(2, 2, 10))
a
apply(a, c(1,2), mean)
rowMeans(a, dims=2)
rep(1,4)
rep(2,3)
mapply(rep, 1:4, 4:1)
noise <- function(n, mean, sd){
rnorm(n, mean, sd)
}
noise(5,1,2)
rnorm
rnorm(5)
rnorm(5, 1)
mean(rnorm(5,1))
mean(rnorm(5,1))
rnorm(1:5, 1:5, 2)
noise
mapply(noise, 1:5, 1:5, 2)
list(noise(1, 1, 2), noise(2, 2, 2), noise(3, 3, 2), noise(4, 4, 2), noise(5, 5, 2))
x <- c(rnorm(10), runif(10), rnorm(10, 1))
x
rnorm
gl
gl(3, 10)
gl(3, 10)
f <- gl(3,10)
tapply(x,f)
tapply(x,f, mean)
tapply(x,f, mean, simplify=FALSE)
range
range(1:10)
range(c(4,3))
q()
gl(3, 10)
typeof(gl(3,10))
rnorm(10,1)
rnorm
mean(rnorm(10,1))
mean(rnorm(10,0))
mean(rnorm(10,0))
mean(rnorm(10,1))
mean(rnorm(10,1))
mean(rnorm(10,1))
mean(rnorm(10,1))
mean(rnorm(10,2))
mean(rnorm(10,2))
mean(rnorm(10,2))
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f<-gl(3,10)
split(x, f)
x
traceback()
mwan(x)
mean(x)
traceback()
lm(y~x)
traceback()
mean(x)
x <- log(-1)
mean(x)
traceback()
debug(lm)
lm
library(datasets)
data(iris)
?iris
iris
iris[[Specious]]
iris[[Species]]
iris$Species
typeof(iris)
tapply(iris$Sepal.Length,iris$Species, mean)
apply(iris[, 1:4], 2, mean)
colMeans(iris)
library(datasets)
data(mtcars)
?mtcars
mtcars
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$cyl, mtcars$mpg, mean)
tapply(mpg, cyl, mean)
split(mtcars, mtcars$cyl)
iris
mtcars
tapply(mtcars$hp, mtcars$cyl, mean)
209.21429 - 82.63636
debug(ls)
ls
1
q()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
numeric
numeric(1)
numeric(2)
numeric(3)
x <- x(1:5)
x <- c(1:5)
x
makeVector(x)
makeVector(c(1:5))
x
makeVector()
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(x)
x <- makeVector()
x
cachemean(x)
x <- makeVector(c(1:5))
x
x$setmean
cachemean(x)
x
cachemean(x)
cachemean(x)
test <- matrix(3,3)
test
test <- matrix(1:9, nrow=3, ncol=3)
test
solve(test)
test <- matrix(c(1,0,0,0,1,0,0,0,1), nrow=3, ncol=3)
test
solve(test)
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
set <- function(y) {
x <<- y
inverseM <<- NULL
}
get <- function() x
setInverse <- function(solve) inverseM <<- solve
getInverse <- function() inverseM
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
test
m <- makeCacheMatrix(test)
x
m
solve
solve(test, ...)
test
solve(test)
solve(test, ...)
mean
solve
cacheSolve <- function(x) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInverse()
if(!is.null(inverseM)) {
message("getting cached matrix")
return(inverseM)
}
mtx <- x$get()
inverseM <- solve(mtx)
x$setInverse(inverseM)
inverseM
}
m
cacheSolve(test)
cacheSolve(m)
q()
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
set <- function(y) {
x <<- y
inverseM <<- NULL
}
get <- function() x
setInverse <- function(solve) inverseM <<- solve
getInverse <- function() inverseM
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInverse()
if(!is.null(inverseM)) {
message("getting cached matrix")
return(inverseM)
}
mtx <- x$get()
inverseM <- solve(mtx)
x$setInverse(inverseM)
inverseM
}
test <- matrix(c(2,0,0),c(0,2,0),c(0,0,2))
test <- c(c(2,0,0),c(0,2,0),c(0,0,2))
test
test <- matrix(test, nrow=3, ncol=3)
test
solve(test)
mtx <- makeCacheMatrix(test)
mtx
cacheSolve(mtx)
cacheSolve(mtx)
cacheSolve(mtx)
cacheSolve(mtx)
test
typeof(test)
test2 <- matrix(c(3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3), rnol=4, ccol=4)
test2 <- matrix(c(3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3), nrow=4, ncol=4)
test2
test2 <- makeCacheMatrix(test2)
test2
solveCache(test2)
cacheSolve(test2)
test1
test
cacheSolve(test)
test
test <- makeCacheMatrix(test)
test
cacheSolve(test)
cacheSolve(test)
test
test2
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
set <- function(y) {
x <<- y
inverseM <<- NULL
}
get <- function() x
setInverse <- function(solve) inverseM <<- solve
getInverse <- function() inverseM
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInverse()
if(!is.null(inverseM)) { ## if there is already a inverse matrix
message("getting cached matrix")
return(inverseM) ## return the inverse of the matrix
}
## if there is no inverse matrix
mtx <- x$get() ## get the matrix
inverseM <- solve(mtx) ## inverse the matrix
x$setInverse(inverseM) ## set the inverse of the matrix
inverseM ## return the inverse matrix
}
cache
test2
test
cacheSolve(test)
test <- matrix(c(2,0,0),c(0,2,0),c(0,0,2))
test <- c(c(2,0,0),c(0,2,0),c(0,0,2))
test
test <- matrix(test, nrow=3, ncol=3)
test
test
source("cacheMatrix.R")
setwd("~/Desktop/CSgod/R Prgramming/Programming Exercise/PA2")
source("cacheMatrix.R")
test
test1 <- makeCacheMatrix(test)
test1
solveCache(test1)
cacheSolve(test1)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
test1
cacheSolve(test1)
cacheSolve(test1)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
cacheSolve(test1)
cacheSolve(test1)
cacheSolve(test1)
cacheSolve(test1)
test2 <- matrix(c(3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3), nrow=4, ncol=4)
test2
test2 <- makeCacheMatrix(test2)
test2
cacheSolve(test2)
cacheSolve(test1)
cacheSolve(test1)
test1
test2
test2 <- makeCacheMatrix(test2)
test2
test3 <- matrix(c(1,0,0,0,1,0,0,0,1), nrow=3, ncol=3)
test3
test3 <- makeCacheMatrix(test3)
test3
cacheSolve(test3)
test1
cachesolve(test1)
cacheSolve(test1)
source("cacheMatrix.R")
test1 <- makeCacheMatrix(test)
cacheSolve(test1)
cacheSolve(test1)
test2
test2 <- matrix(c(3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3), rnol=4, ccol=4)
test2 <- matrix(c(3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3), nrow=4, ncol=4)
test2 <- makeCacheMatrix(test2)
test2
cacheSolve(test2)
test2
test11 <- matrix(c(1,0,0,0,1,0,0,0,1),nrow=3, ncol=3)
test11
solve(test11)
solve(test2)
test2
test11
source("cahceMatrix.R")
source("cahcematrix.R")
solve(test2)
source("cachematrix.R")
test1 <- makeCacheMatrix(test11)
test1
cacheSolve(test1)
cacheSolve(test1)
test2
cacheSolve(test2)
cacheSolve(test2)
source("cachematrix.R")
test2
test1 <- makeCacheMatrix(test11)
cacheSolve(test2)
cacheSolve(test1)
q()
